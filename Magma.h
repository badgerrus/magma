#pragma once
#include<stdio.h>

typedef unsigned char uint8;
typedef unsigned long uint32;
typedef unsigned long long uint64; // Тип данных для блока в 64 бита

typedef struct Block64 {
	uint32 left, right; // левая и правая половины блока по 32 бита
}
Block64;// S-боксы из стандарта ГОСТ Р34.12-2015

const uint8 s0[16] = { 12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1 };
const uint8 s1[16] = { 6, 8, 2, 3, 9, 10, 5, 12, 1, 14, 4, 7, 11, 13, 0, 15 };
const uint8 s2[16] = { 11, 3, 5, 8, 2, 15, 10, 13, 14, 1, 7, 4, 12, 9, 6, 0 };
const uint8 s3[16] = { 12, 8, 2, 1, 13, 4, 15, 6, 7, 0, 10, 5, 3, 14, 9, 11 };
const uint8 s4[16] = { 7, 15, 5, 10, 8, 1, 6, 13, 0, 9, 3, 14, 11, 4, 2, 12 };
const uint8 s5[16] = { 5, 13, 15, 6, 9, 2, 12, 10, 11, 7, 8, 1, 4, 3, 14, 0 };
const uint8 s6[16] = { 8, 14, 2, 5, 6, 9, 1, 12, 15, 4, 11, 0, 13, 10, 3, 7 };
const uint8 s7[16] = { 1, 7, 14, 13, 0, 5, 8, 3, 4, 15, 10, 6, 9, 12, 11, 2 };

// Циклический сдвиг на 11 бит влево
uint32 T11(uint32 x) {
	return (x << 11) | (x >> 21);
}

// Применение S-боксов к блоку данных размером 32 бита
uint32 S(uint32 x) {
	return
		(s7[(x >> 28) & 0xf] << 28) |
		(s6[(x >> 24) & 0xf] << 24) |
		(s5[(x >> 20) & 0xf] << 20) |
		(s4[(x >> 16) & 0xf] << 16) |
		(s3[(x >> 12) & 0xf] << 12) |
		(s2[(x >> 8) & 0xf] << 8) |
		(s1[(x >> 4) & 0xf] << 4) |
		s0[x & 0xf];
}

// Функция зашифрования блока данных размером 64 бит,
// т. е. блока (a.left, a.right). На выходе получается блок
// шифрованного текста (b.left, b.right).

void Encrypt(Block64 a, Block64* b, uint32* key) {
	int i;
	uint64 q, buf; // q - раундовый ключ
	for (i = 0; i < 32; i++) {
		if (i < 24)
			q = key[i % 8];
		else q = key[7 - i % 8];
		b->left = a.right;
		b->right = T11(S(a.right + q)) ^ a.left;
		a = *b;
	}
	buf = b->right; b->right = b->left; b->left = buf;
}

// Функция расшифрования блока данных размером 64 бит,
// т. е. блока (b.left,b.right). 
// На выходе получается блок открытого текста (a.left,a.right).

void Decrypt(Block64 b, Block64* a, uint32* key) {
	int i;
	uint32 q, buf;
	for (i = 0; i < 32; i++) {
		if (i < 8)q = key[i % 8];
		else q = key[7 - i % 8];
		a->left = b.right;
		a->right = T11(S(b.right + q)) ^ b.left;
		b = *a;
	}
	buf = a->right; a->right = a->left; a->left = buf;
}
// Рацеев, С. М. Реализации некоторых криптосистем и корректирующих кодов  
// С. М. Рацеев. — Санкт-Петербург : Лань, 2024. — ISBN 978-5-507-47919-1. 
// — Текст : электронный // Лань : электронно-библиотечная система. 
// — URL: https://e.lanbook.com/book/356009 (дата обращения: 18.09.2024). 
// — Режим доступа: для авториз. пользователей. — С. 30.).
